"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var utils_1 = require("@typescript-eslint/utils");
var createRule = utils_1.ESLintUtils.RuleCreator(function () { return ''; });
function isOpeningParenToken(token) {
    return token.value === '(' && token.type === 'Punctuator';
}
function isClosingParenToken(token) {
    return token.value === ')' && token.type === 'Punctuator';
}
function isParenthesised(sourceCode, node) {
    var previousToken = sourceCode.getTokenBefore(node, {
        filter: isOpeningParenToken,
    });
    var nextToken = sourceCode.getTokenAfter(node, {
        filter: isClosingParenToken,
    });
    return (!!previousToken &&
        !!nextToken &&
        previousToken.range[1] <= node.range[0] &&
        nextToken.range[0] >= node.range[1]);
}
exports.default = createRule({
    name: 'redundant-undefined',
    meta: {
        docs: {
            description: 'Forbids optional parameters to include an explicit `undefined` in their type and requires to use `undefined` in optional properties.',
            recommended: 'error',
        },
        fixable: 'code',
        messages: {
            exactOptionalPropertyTypesError: 'Property is optional, so `undefined` must be included in the type.',
            propertyOptionalError: 'Property is optional, so no need to include `undefined` in the type.',
            parameterOptionalError: 'Parameter is optional, so no need to include `undefined` in the type.',
        },
        schema: [
            {
                type: 'object',
                properties: {
                    followExactOptionalPropertyTypes: { type: 'boolean' },
                },
            },
        ],
        type: 'problem',
    },
    defaultOptions: [
        {
            followExactOptionalPropertyTypes: false,
        },
    ],
    create: function (context, _a) {
        var followExactOptionalPropertyTypes = _a[0].followExactOptionalPropertyTypes;
        var sourceCode = context.getSourceCode();
        function containsTypeNode(node, kind) {
            return node.type === utils_1.AST_NODE_TYPES.TSUnionType
                ? node.types.find(function (n) { return n.type === kind; })
                : node.type === utils_1.AST_NODE_TYPES.TSUndefinedKeyword
                    ? node
                    : undefined;
        }
        function isFunction(node) {
            return (node.type === utils_1.AST_NODE_TYPES.FunctionDeclaration ||
                node.type === utils_1.AST_NODE_TYPES.FunctionExpression ||
                node.type === utils_1.AST_NODE_TYPES.ArrowFunctionExpression);
        }
        function isOptionalParam(node) {
            switch (node.type) {
                case utils_1.AST_NODE_TYPES.Identifier:
                    return !!(node.optional &&
                        node.parent &&
                        (node.parent.type === utils_1.AST_NODE_TYPES.TSParameterProperty ||
                            (isFunction(node.parent) &&
                                node.parent.params.indexOf(node) >= 0)));
                case utils_1.AST_NODE_TYPES.TSUndefinedKeyword:
                case utils_1.AST_NODE_TYPES.TSTypeAnnotation:
                case utils_1.AST_NODE_TYPES.TSUnionType:
                    return !!node.parent && isOptionalParam(node.parent);
                default:
                    return false;
            }
        }
        function isOptionalProperty(node) {
            switch (node.type) {
                case utils_1.AST_NODE_TYPES.TSAbstractPropertyDefinition:
                case utils_1.AST_NODE_TYPES.TSPropertySignature:
                case utils_1.AST_NODE_TYPES.PropertyDefinition:
                    return !!node.optional;
                case utils_1.AST_NODE_TYPES.TSUndefinedKeyword:
                case utils_1.AST_NODE_TYPES.TSTypeAnnotation:
                case utils_1.AST_NODE_TYPES.TSUnionType:
                    return !!node.parent && isOptionalProperty(node.parent);
                default:
                    return false;
            }
        }
        function removeUndefinedFixer(fixer, node) {
            var _a, _b;
            if (((_a = node.parent) === null || _a === void 0 ? void 0 : _a.type) === utils_1.AST_NODE_TYPES.TSUnionType) {
                var types = node.parent.types;
                var typePos = node.parent.types.indexOf(node);
                var prevType = types[typePos - 1];
                var nextType = types[typePos + 1];
                if (prevType) {
                    return fixer.removeRange([prevType.range[1], node.range[1]]);
                }
                if (nextType) {
                    return fixer.removeRange([node.range[0], nextType.range[0]]);
                }
            }
            if (((_b = node.parent) === null || _b === void 0 ? void 0 : _b.type) === utils_1.AST_NODE_TYPES.TSTypeAnnotation) {
                return fixer.removeRange(node.parent.range);
            }
            return null;
        }
        function checkUndefined(node) {
            if (isOptionalParam(node)) {
                context.report({
                    node: node,
                    messageId: 'parameterOptionalError',
                    fix: function (fixer) { return removeUndefinedFixer(fixer, node); },
                });
            }
            if (!followExactOptionalPropertyTypes && isOptionalProperty(node)) {
                context.report({
                    node: node,
                    messageId: 'propertyOptionalError',
                    fix: function (fixer) { return removeUndefinedFixer(fixer, node); },
                });
            }
        }
        function checkProperty(node) {
            if (followExactOptionalPropertyTypes &&
                node.optional &&
                node.typeAnnotation &&
                !(containsTypeNode(node.typeAnnotation.typeAnnotation, utils_1.AST_NODE_TYPES.TSUndefinedKeyword) ||
                    containsTypeNode(node.typeAnnotation.typeAnnotation, utils_1.AST_NODE_TYPES.TSAnyKeyword))) {
                var typeNode_1 = node.typeAnnotation.typeAnnotation;
                context.report({
                    node: node,
                    messageId: 'exactOptionalPropertyTypesError',
                    fix: function (fixer) {
                        var lastTypeNode = typeNode_1.type === utils_1.AST_NODE_TYPES.TSUnionType
                            ? typeNode_1.types[typeNode_1.types.length - 1]
                            : typeNode_1;
                        var needParens = (lastTypeNode.type === utils_1.AST_NODE_TYPES.TSFunctionType ||
                            lastTypeNode.type === utils_1.AST_NODE_TYPES.TSConstructorType ||
                            lastTypeNode.type === utils_1.AST_NODE_TYPES.TSConditionalType) &&
                            !isParenthesised(sourceCode, lastTypeNode);
                        var fixers = [];
                        if (needParens) {
                            fixers.push(fixer.insertTextBefore(lastTypeNode, '('));
                            fixers.push(fixer.insertTextAfter(lastTypeNode, ')'));
                        }
                        fixers.push(fixer.insertTextAfter(typeNode_1, ' | undefined'));
                        return fixers;
                    },
                });
            }
        }
        return {
            TSAbstractPropertyDefinition: checkProperty,
            TSPropertySignature: checkProperty,
            PropertyDefinition: checkProperty,
            TSUndefinedKeyword: checkUndefined,
        };
    },
});
